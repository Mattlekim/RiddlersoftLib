// GENERATED BY BRUTE
// MyGame.NSwitch

#include <mscorlib/1nternal/Brute.h>

#include "mscorlib/System/Exception.h"
#include "mscorlib/System/String.h"

#include "mscorlib/System/String.inl"

#include <nn/account/account_Api.h>
#include <nn/account/account_ApiForApplications.h>
#include <nn/oe/oe_ApplicationControlApis.h>
#include <nn/oe.h>
#include <nn/fs.h>
#include <nn/fs/fs_SaveDataForDebug.h>
#include <nn/os/os_MemoryHeap.h>
#include <nn/swkbd/swkbd_Api.h>
#include <nn/swkbd/swkbd_Result.h>
#include <nn/err.h>

#include <stdlib.h>
#include <malloc.h>


namespace Riddlersoft {
	namespace Core {
		namespace Switch {

			nn::account::Uid _activeUser = nn::account::InvalidUid;
            nn::account::UserHandle handle;

			void NSwitch$_$S_Init()
			{
				// Initialize the account library.
				nn::account::Initialize();

				nn::Result result;

				// If the NMETA ensures the user and saves space have already
				// been checked... so nothing to do here, just get the user.
				result = nn::account::OpenPreselectedUser(&handle);
				if (result.IsFailure())
				{
					nn::err::ShowError(result);
					NN_ABORT("No preselected user found!");
				}

				result = nn::account::GetUserId(&_activeUser, handle);
				if (result.IsFailure())
				{
					nn::err::ShowError(result);
					NN_ABORT("Cannot get user id!");
				}

				result = nn::fs::EnsureSaveData(_activeUser);
				if (result.IsFailure())
				{
					nn::err::ShowError(result);
					NN_ABORT("Cannot ensure save data!");
				}

				// We have a valid user and the save data area has
				// the space required as defined in the nmeta file.

				// Helper... if you want the system to save to a local directory
				// on the host PC then uncomment this line:
				//nn::fs::SetSaveDataRootPath("D:\\Projects\\MyGame\\NxSaves");
			}

			bool NSwitch$_$S_Mount()
			{
				// Mount the save data.
				nn::Result result;
				result = nn::fs::MountSaveData("save", _activeUser);
				if (result.IsFailure())
				{
					nn::err::ShowError(result);
					return false;
				}

				return true;
			}

			void NSwitch$_$S_CommitSaveData()
			{
				nn::Result result;
				result = nn::fs::CommitSaveData("save");
				if (result.IsFailure())
					nn::err::ShowError(result);
			}

			void NSwitch$_$S_Unmount()
			{
				nn::fs::Unmount("save");
			}

			::System::String* NSwitch$_$S_GetNickName()
			{
				if (_activeUser == nn::account::InvalidUid)
					return nullptr;
				// Internal Call!
				nn::account::Nickname user_nickname;
				nn::account::GetNickname(&user_nickname, _activeUser);
				return ::System::String$_$Ctor(nullptr, (sbyte_bt*)user_nickname.name);
			//	return nullptr;
			}

			bool NSwitch$_$S_IsNSAAccount()
			{
				if (_activeUser == nn::account::InvalidUid)
					return false;
				// Internal Call!
				bool pout = nullptr;

				nn::account::IsNetworkServiceAccountAvailable(&pout, handle);
				return pout;
				//	return nullptr;
			}

			::System::String* NSwitch$_$S_SetVibration(int index, float leftMotorAmplitudeLow, float leftMotorAmplitudeHigh, float leftMotorLow, float leftMotorHigh, float rightMotorAmplitudeLow, float rightMotorAmplitudeHigh, float rightMotorLow, float rightMotorHigh)
			{
				// Internal Call!
				throw ::System::Exception$_$Ctor(nullptr);
			}

		
		}
	}
} // namespace Riddlersoft.Core.Switch

